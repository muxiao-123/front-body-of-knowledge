- 什么是作用域，作用域链又是啥
```
  作用域
  作用域是一套规则 用于确定在何处以及如何查找变量(标识符)，
  如果查找目的时对象进行赋值就用LHS查找
  如果目的是获取变量的值就用RHS查找
  作用域链
  当前作用域中没有查找变量，回到上层继续查找，没有继续向上，这个查找过程形成一条链路，俗称作用域链s
```

- 谈谈你对闭包的理解
```
当函数能记住并访问所在词法作用域时就产生了闭包，即使是在当前词法作用域之外执行
从技术上讲，闭包是产生在定义时
应用：IIFE, 回调函数，模块等随处都可见
弊端：增大内存消耗（保留对变量标识符的引用，即使当前用不上)，不利已垃圾回收机制清理
```

- 说说你对原型的理解
```md
- 每个对象上的[[prototype]]属性都会关联一个[[prototype]]属性
- 每当在实例上找不到属性或者方法时就会
- 在自身的原型属性上找, 还是找不到，在原型属性上的原型上找，直到找到，或者原型属性为 `null`
- 这个过程会形成一个查找链也就是常说的原型链
```

- 谈谈你对`this`的看法，以及判断`this`指向
```md
- js特有机制
- 确定this方式 new > 显示 > 隐 > 默（基本| 可能会出现隐式丢失）
  - 默认方式
    - 函数单独调用 没有在任何上下文环境 this 即是全局对象(window | undefined | global)
  - 隐式
    - 函数被其他对象直接调用，或者说函数被其他对象所包含 this 即是所调用对象
  - 显示
    - 通过内置方式绑定 call, apply, bind this 就是传入的对象
  - new 方式
    - this 指的是新创建的对象
- 箭头函数 方式
  - 即声明时this，不会改变
```

- 知道继承吗，js中继承都有哪些方式呢，说出你知道的方式
```
```
- `new` 的过程究竟发生了什么
`new` 指令其实就是普通函数调用，没有什么类不类，构造函数之说，只是方便开发者便已理解而与
```md
- 创建（构造）一个全新对象
- 新对象执行[[原型]]连接
- 对象会绑定到函数调用的this上
- 如果函数没有返回其他对象，那么new 表达式的函数调用会自动返回这个新对象
```

- 执行上下文理解
```
指当前执行环境中的变量、函数声明、作用域链、this等信息
1. 生命周期
  - 创建阶段
    - 生成变量对象、建立作用域链、确定this的指向
  - 执行阶段
    - 变量赋值、函数的引用、执行其他代码
2. 执行上下文里包含当前所有信息 大概三种
- VO变量对象 -> 存储变量，函数声明以及arguments对象等信息（只能全局执行上下文中访问）
- 作用域 -> 当前词法作用域的所有信息，通过通过[[scope]]访问
- this
3. js引擎在执行代码是会生成3个执行上下文
- 全局执行上下文
- 函数执行上下文
  - 函数上下文只能访问AO活动对象其他对象信息，通过scope链访问
- eval执行上下文
4. 特点
  1. 单线程，只在主线程上运行
  2. 同步执行，从上向下按顺序执行
  3. 全局上下文只有一个，也就是window对象
  4. 函数每调用一次就会产生一个新的执行上下文环境
5. 执行栈
  - 描述：是一种先进后出的数据结构，用来存储代码运行的所有执行上下文
  1. 当 JS 引擎第一次遇到js脚本时，会创建一个全局的执行上下文并且压入当前执行栈
  2. 每当JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部
  3. 当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文
  4. 一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文
```


- 实现自己的instanceof
  - 检查对象原型是否属于另外一个对象
```js
function instanceof (obj, fn) {
  const prototype = fn.prototype
  let proto = obj.__proto__
  while (true) {
    if (!proto) {
      return false
    }
    if (proto === prototype) {
      return true
    }
    proto = proto.__proto__
  }
} 
```